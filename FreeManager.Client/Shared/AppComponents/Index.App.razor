@implements IDisposable
@using Humanizer
@inject BlazorDataModel Model
@inject IJSRuntime JS

@if(Model.Loaded && Model.LoggedIn && Model.View == _pageName) {
    if(Model.Tenant.TenantSettings.LogoIncludedOnHomePage && !String.IsNullOrWhiteSpace(LogoUrl)) {
        <div class="home-page-logo-container">
            <img src="@LogoUrl" class="logo-homepage" />
        </div>
    }

    <h1 class="page-title">
        @if(!String.IsNullOrWhiteSpace(Model.Tenant.TenantSettings.AppIcon)) {
            <i>@((MarkupString)Model.Tenant.TenantSettings.AppIcon)</i>
        }
        <Language Tag="Welcome" ReplaceSpaces="true" /> @Model.User.FirstName
    </h1>

    <!-- App Repo Explorer -->
    <div class="card mt-3">
        <div class="card-header">
            <strong>.app File Explorer (from Public Git Repo)</strong>
        </div>
        <div class="card-body">
            <div class="row g-2 align-items-end">
                <div class="col-md-8">
                    <label class="form-label" for="repoUrl">Public Repo URL</label>
                    <input id="repoUrl" class="form-control" placeholder="https://github.com/org/repo.git"
                           @bind="RepoUrl" />
                </div>
                <div class="col-md-4">
                    <button class="btn btn-primary me-2" @onclick="CloneRepo" disabled="@IsBusy">
                        <Icon Name="Refresh" /> Clone
                    </button>
                    @if(!string.IsNullOrWhiteSpace(RepoId)) {
                        <span class="text-muted">Repo Id: @RepoId</span>
                    }
                </div>
            </div>

            @if(Messages.Count > 0) {
                <div class="alert alert-warning mt-3">
                    <ul class="mb-0">
                        @foreach(var m in Messages) {
                            <li>@m</li>
                        }
                    </ul>
                </div>
            }

            @if(!string.IsNullOrWhiteSpace(RepoId)) {
                <div class="row mt-3">
                    <div class="col-md-4">
                        <div class="mb-2"><strong>*.app.* Files</strong></div>
                        <div class="list-group small" style="max-height: 420px; overflow:auto;">
                            @if(Files.Count == 0) {
                                <div class="list-group-item text-muted">No .app files found.</div>
                            } else {
                                @foreach(var f in Files) {
                                    var active = f.RelativePath == SelectedPath ? "active" : "";
                                    <button type="button" class="list-group-item list-group-item-action @active"
                                            title="@f.RelativePath"
                                            @onclick="@(() => LoadFile(f.RelativePath))">
                                        @f.RelativePath
                                    </button>
                                }
                            }
                        </div>
                    </div>

                    <div class="col-md-8">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div>
                                <strong>@(SelectedPath ?? "Select a file")</strong>
                            </div>
                            <div>
                                @if(!IsEditing) {
                                    <button class="btn btn-secondary" disabled="@(!CanEdit)" @onclick="BeginEdit">
                                        <Icon Name="Edit" /> Edit
                                    </button>
                                } else {
                                    <button class="btn btn-primary me-2" @onclick="SaveEdits">
                                        <Icon Name="Save" /> Save
                                    </button>
                                    <button class="btn btn-outline-secondary" @onclick="CancelEdits">
                                        <Icon Name="Back" /> Cancel
                                    </button>
                                }
                            </div>
                        </div>

                        <div>
                            @if(string.IsNullOrWhiteSpace(SelectedPath)) {
                                <div class="text-muted">Choose a file from the list to view.</div>
                            } else {

                                <!-- Monaco (re-created when mode changes so ReadOnly applies immediately) -->
                                <MonacoEditor @ref="monacoEditor"
                                              @key="@($"{SelectedPath}-{(IsEditing ? "edit" : "ro")}")"
                                              Id="view-source-monaco-editor"
                                              Language="@CurrentLanguage"
                                              ReadOnly="@(!IsEditing)"
                                              Timeout="500"
                                              Value="@EditorText" />

                                <div class="small text-muted mt-2">
                                    Language: <code>@CurrentLanguage</code>
                                    @if(IsEditing) {
                                        <span> · Editing</span>
                                    } else {

                                        <span> · Read-only</span>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
}

@code {
    protected string _pageName = "home";

    // ----- State -----
    private string RepoUrl { get; set; } = "https://github.com/WSU-EIT/FreeManager.git";
    private string RepoId { get; set; } = string.Empty;
    private List<DataObjects.AppRepoFileItem> Files { get; set; } = new();
    private string? SelectedPath { get; set; }
    private string EditorText { get; set; } = string.Empty;
    private string OriginalText { get; set; } = string.Empty;
    private bool IsEditing { get; set; } = false; // default read-only
    private bool IsBusy { get; set; } = false;
    private List<string> Messages { get; set; } = new();

    // Optional focus helpers from your earlier snippet
    [Parameter] public int? FocusLine { get; set; }
    [Parameter] public int? FocusColumn { get; set; }
    [Parameter] public string? IntroMessage { get; set; }
    [Parameter] public string Language { get; set; } = MonacoEditor.MonacoLanguage.html;
    [Parameter] public string Source { get; set; } = String.Empty;

    MonacoEditor monacoEditor = null!;

    protected override async Task OnInitializedAsync()
    {
        if(FocusLine.HasValue) {
            int line = FocusLine.Value;
            int column = FocusColumn.HasValue ? FocusColumn.Value : 1;

            Helpers.SetTimeout(async () => {
                await monacoEditor.Editor.RevealLineInCenter(line, BlazorMonaco.Editor.ScrollType.Immediate);
                await monacoEditor.Editor.SetPosition(new BlazorMonaco.Position {
                    LineNumber = line,
                    Column = column,
                }, "");
                await monacoEditor.Editor.Focus();
            }, 500);
        }
    }

    public void Dispose()
    {
        Model.OnChange -= OnDataModelUpdated;
    }

    protected override void OnInitialized()
    {
        Model.OnChange += OnDataModelUpdated;
    }

    protected void OnDataModelUpdated()
    {
        if(Model.View == _pageName) {
            StateHasChanged();
        }
    }

    public async Task LoadData()
    {
        // Perform any app-specific data loading here.
    }

    protected string LogoUrl {
        get {
            if(Model.Tenant.TenantSettings.Logo.HasValue && Model.Tenant.TenantSettings.Logo != Guid.Empty) {
                return Model.ApplicationUrl + "File/View/" + ((Guid)Model.Tenant.TenantSettings.Logo).ToString();
            } else {
                return String.Empty;
            }
        }
    }

    // ----- Actions -----

    private async Task CloneRepo()
    {
        IsBusy = true;
        Messages.Clear();
        Files.Clear();
        SelectedPath = null;
        EditorText = OriginalText = string.Empty;
        IsEditing = false;

        var body = new DataObjects.AppRepoCloneRequest { RepoUrl = RepoUrl };
        // Root-relative (avoid "~/" 405)
        var result = await Helpers.GetOrPost<DataObjects.AppRepoCloneResponse>("api/AppRepo/Clone", body);

        if(result != null) {
            RepoId = result.RepoId ?? string.Empty;
            Files = result.Files ?? new();
            if(result.Messages?.Count > 0)
                Messages.AddRange(result.Messages);
        } else {
            Messages.Add("No response from server.");
            RepoId = string.Empty;
        }

        IsBusy = false;
        StateHasChanged();
    }

    private async Task LoadFile(string relativePath)
    {
        if(string.IsNullOrWhiteSpace(RepoId))
            return;

        SelectedPath = relativePath;
        IsEditing = false; // load in read-only

        var req = new DataObjects.AppRepoFileContentRequest {
            RepoId = RepoId,
            RelativePath = relativePath
        };

        var result = await Helpers.GetOrPost<DataObjects.AppRepoFileContentResponse>("api/AppRepo/Content", req);
        if(result != null && result.Result) {
            EditorText = result.Content ?? string.Empty;
            OriginalText = EditorText;
        } else {
            EditorText = string.Empty;
            OriginalText = string.Empty;
            Messages.Clear();
            if(result?.Messages?.Count > 0)
                Messages.AddRange(result.Messages);
            else
                Messages.Add("Failed to load file.");
        }

        // ensure Monaco shows the latest content
        if(monacoEditor is not null) {
            await monacoEditor.SetValue(EditorText);
        }

        StateHasChanged();
    }

    private bool CanEdit => !string.IsNullOrWhiteSpace(SelectedPath) && !IsBusy;

    private async Task BeginEdit()
    {
        if(!CanEdit)
            return;

        IsEditing = true;

        // focus the editor after it re-renders in editable mode
        Helpers.SetTimeout(async () => {
            if(monacoEditor is not null && monacoEditor.Editor is not null) {
                await monacoEditor.Editor.Focus();
            }
        }, 100);
    }

    // Save: log current editor contents and return to read-only (no server write yet)
    private async Task SaveEdits()
    {
        // grab the live value from Monaco
        var current = monacoEditor is not null ? await monacoEditor.GetValue() : EditorText;

        EditorText = current;
        OriginalText = current;

        // log to the browser console
        await JS.InvokeVoidAsync("console.log", "[Repo Save] (not persisted)", new {
            path = SelectedPath,
            length = current?.Length ?? 0
        });
        await JS.InvokeVoidAsync("console.log", current);

        IsEditing = false; // back to read-only

        // reapply value to ensure the read-only instance shows the latest text
        if(monacoEditor is not null) {
            await monacoEditor.SetValue(EditorText);
        }

        StateHasChanged();
    }

    private async Task CancelEdits()
    {
        // discard in-memory edits and restore original text
        EditorText = OriginalText;
        IsEditing = false;

        if(monacoEditor is not null) {
            await monacoEditor.SetValue(EditorText);
            await monacoEditor.ReadOnly = true;
        }

        StateHasChanged();
    }

    // ---- Helpers ----

    private string CurrentLanguage => GetLanguageForPath(SelectedPath);

    private static string GetLanguageForPath(string? path)
    {
        if(string.IsNullOrWhiteSpace(path))
            return MonacoEditor.MonacoLanguage.plaintext;

        var ext = System.IO.Path.GetExtension(path).ToLowerInvariant();

        return ext switch {
            ".htm" or ".html" => MonacoEditor.MonacoLanguage.html,
            ".js" => MonacoEditor.MonacoLanguage.javascript,
            ".ts" => MonacoEditor.MonacoLanguage.typescript,
            ".css" => MonacoEditor.MonacoLanguage.css,
            ".scss" => MonacoEditor.MonacoLanguage.scss,
            ".json" => MonacoEditor.MonacoLanguage.json,
            ".xml" => MonacoEditor.MonacoLanguage.xml,
            ".yml" or ".yaml" => MonacoEditor.MonacoLanguage.yaml,
            ".md" or ".markdown" => MonacoEditor.MonacoLanguage.markdown,
            ".sql" => MonacoEditor.MonacoLanguage.sql,
            ".cs" => MonacoEditor.MonacoLanguage.csharp,
            ".razor" => MonacoEditor.MonacoLanguage.razor,
            ".php" => MonacoEditor.MonacoLanguage.php,
            ".py" => MonacoEditor.MonacoLanguage.python,
            _ => MonacoEditor.MonacoLanguage.plaintext
        };
    }
}
